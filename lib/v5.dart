// ignore_for_file: constant_identifier_names

import 'package:uuid/data.dart';

import 'dart:convert';
import 'dart:typed_data';
import 'enums.dart';
import 'parsing.dart';
import 'v4.dart';

import 'package:crypto/crypto.dart' as crypto;

class UuidV5 {
  final GlobalOptions? goptions;

  @Deprecated('Please use the Namespace enum in enums.dart instead.')
  static const NAMESPACE_DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
  @Deprecated('Please use the Namespace enum in enums.dart instead.')
  static const NAMESPACE_URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
  @Deprecated('Please use the Namespace enum in enums.dart instead.')
  static const NAMESPACE_OID = '6ba7b812-9dad-11d1-80b4-00c04fd430c8';
  @Deprecated('Please use the Namespace enum in enums.dart instead.')
  static const NAMESPACE_X500 = '6ba7b814-9dad-11d1-80b4-00c04fd430c8';
  @Deprecated('Please use the Namespace enum in enums.dart instead.')
  static const NAMESPACE_NIL = '00000000-0000-0000-0000-000000000000';

  const UuidV5({this.goptions});

  /// Internal method to generate v5 UUID from raw bytes
  String _generateFromBytes(String? namespace, List<int> nameBytes,
      {V5Options? options}) {
    // Check if user wants a random namespace generated by v4() or a NIL namespace.
    var useRandom = options?.randomNamespace ?? true;

    // If useRandom is true, generate UUIDv4, else use NIL
    var blankNS = useRandom
        ? UuidV4(goptions: goptions).generate(options: options?.v4options)
        : Namespace.nil.value;

    // Use provided namespace, or use whatever is decided by options.
    namespace = (namespace != null) ? namespace : blankNS;

    // Convert namespace UUID to Byte List
    var bytes = UuidParsing.parse(namespace);

    // Generate SHA1 using namespace concatenated with name
    var hashBytes = crypto.sha1.convert([...bytes, ...nameBytes]).bytes;

    // per 4.4, set bits for version and clockSeq high and reserved
    hashBytes[6] = (hashBytes[6] & 0x0f) | 0x50;
    hashBytes[8] = (hashBytes[8] & 0x3f) | 0x80;

    return UuidParsing.unparse(hashBytes.sublist(0, 16));
  }

  /// v5() Generates a namespace & name-based version 5 UUID
  ///
  /// By default it will generate a string based on a provided uuid namespace and
  /// name, and will return a string.
  ///
  /// The [namespace] parameter is the UUID namespace (as a String).
  /// The [name] parameter is a String that will be converted to UTF-8 bytes.
  ///
  /// For binary data input, use [generateFromBytes] instead.
  ///
  /// http://tools.ietf.org/html/rfc4122.html#section-4.4
  String generate(String? namespace, String? name, {V5Options? options}) {
    var nameBytes = name != null ? utf8.encode(name) : <int>[];
    return _generateFromBytes(namespace, nameBytes, options: options);
  }

  /// v5FromBytes() Generates a namespace & name-based version 5 UUID from binary data
  ///
  /// By default it will generate a string based on a provided uuid namespace and
  /// binary name data, and will return a string.
  ///
  /// The [namespace] parameter is the UUID namespace (as a String).
  /// The [name] parameter is a Uint8List containing arbitrary binary data.
  /// This allows for generating UUIDs from raw bytes as per RFC 4122 / RFC 9562.
  ///
  /// http://tools.ietf.org/html/rfc4122.html#section-4.4
  String generateFromBytes(String? namespace, Uint8List? name,
      {V5Options? options}) {
    var nameBytes = name ?? Uint8List(0);
    return _generateFromBytes(namespace, nameBytes, options: options);
  }
}
